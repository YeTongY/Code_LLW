# ==============================================================================
# LLW_Project 的 Makefile (适用于 Windows + GCC/MinGW-w64)
#
# [使用方法]
# 1. 确保你已经安装了 MSYS2 或 Git for Windows (提供了 bash 环境)。
# 2. 确保 make 和 g++ 已经添加到了系统的 PATH 环境变量中。
# 3. 在 MSYS2 MinGW64 终端（或 Git Bash）中，进入项目根目录，然后：
#    - 输入 `make` 或 `make all` 来编译整个项目。
#    - 输入 `make clean` 来删除所有编译生成的文件。
#    - 编译后，可执行文件会生成在 `build/` 文件夹中。
#
# [环境要求]
# - 推荐使用 MSYS2 MinGW64 终端，命令：
#   pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-make
# - 或使用 Git Bash (Git for Windows 自带)
# - 不支持原生 Windows cmd/PowerShell（因为缺少 Unix 命令）
#
# [常见问题]
# - 如果编译时输出的中文显示为乱码（如 "姝ｅ湪缂栬瘧"），这是正常现象。
#   原因：make 使用 UTF-8 编码，而终端可能使用其他编码。
#   注意：乱码不影响编译结果，只是显示问题，可以忽略。
# ==============================================================================

# 1. 编译器和编译参数
# ------------------------------------------------------------------------------
# 使用 g++ 作为 C++ 编译器
CC = g++
# CFLAGS 是用于编译 C 和 C++ 文件的参数
# -Wall: 开启所有警告，帮助你写出更规范的代码
# -g:    在可执行文件中包含调试信息，方便 GDB 调试
# -O1:   开启基础的编译优化
CFLAGS = -Wall -g -O1
# 指定使用 C++17 标准
CPPFLAGS = -std=c++17

# 2. 文件夹路径定义
# ------------------------------------------------------------------------------
# 存放 .cpp 源代码的文件夹
SRC_DIR = src
# 存放 .exe 和 .o (目标文件) 的输出文件夹
BUILD_DIR = build
# 存放 Raylib 库的文件夹
LIB_DIR = lib/raylib

# 3. Raylib 相关的路径和库
# ------------------------------------------------------------------------------
# 告诉编译器去哪里找 raylib.h 等头文件
INCLUDES = -I$(LIB_DIR)/include
# 告诉链接器去哪里找 libraylib.a 等库文件
LDFLAGS = -L$(LIB_DIR)/lib
# 需要链接的库列表
# 在 Windows 上使用 Raylib，这些都是必需的
LIBS = -lraylib -lopengl32 -lgdi32 -lwinmm

# 4. 文件和最终目标
# ------------------------------------------------------------------------------
# 你最终想要生成的可执行文件的名字
TARGET = $(BUILD_DIR)/LLW.exe
# 自动查找 src/ 文件夹下所有的 .cpp 文件
SRCS = $(wildcard $(SRC_DIR)/*.cpp)
# 根据找到的 .cpp 文件列表，生成一个对应的 .o (目标文件) 列表
# 例如，src/main.cpp 会被转换成 build/main.o
OBJS = $(patsubst $(SRC_DIR)/%.cpp, $(BUILD_DIR)/%.o, $(SRCS))

# ==============================================================================
# 编译规则 (告诉 make 如何一步步构建项目)
# ==============================================================================

# 第一个规则是默认规则。当你只输入 "make" 时，就会执行它。
# 它的目标是生成最终的 $(TARGET) 文件。
all: $(TARGET)

# 链接规则：如何生成最终的 .exe 文件
# 这个规则依赖于所有的 .o 文件都已经被成功编译出来。
$(TARGET): $(OBJS)
	@echo "链接生成可执行文件: $(TARGET)"
	$(CC) $(OBJS) -o $(TARGET) $(LDFLAGS) $(LIBS)
	@echo "编译完成! 请运行: build\LLW.exe"

# 模式规则：如何将一个 .cpp 文件编译成一个 .o 文件
# 这条规则的意思是："为了制作一个 build/目录下的.o文件，你需要一个 src/目录下的同名.cpp文件"
# $< 代表依赖文件 (即 .cpp)，$@ 代表目标文件 (即 .o)
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp
	@echo "正在编译: $<"
	@mkdir -p $(BUILD_DIR)
	$(CC) $(CFLAGS) $(CPPFLAGS) $(INCLUDES) -c $< -o $@

# 清理规则：用于删除所有编译产物
# 当你运行 "make clean" 时，会执行这里的命令
clean:
	@echo "正在清理项目..."
	@rm -rf $(BUILD_DIR)
	@echo "清理完成。"

# .PHONY 用于声明一个"伪目标"，它不是一个真正的文件名。
# 这样做可以防止 make 因为存在一个名为 "clean" 的文件而出错。
.PHONY: all clean
