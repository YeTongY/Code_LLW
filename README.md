# 代号：LLW说明文档

## 项目简介：
本项目是一个简易的俯视角像素风JRPG，以Raylib作为核心图形库。
本项目以函数指针为基础从底层构建了一套轻量级的游戏框架。游戏以“TUT科协”为背景，融合了赛博朋克与故障艺术风格，玩家将扮演主角 Taffy，在被病毒“LLW”侵蚀的办公大楼中探索真相，净化被感染的同伴。

项目核心目标是实现 RPG 游戏的底层逻辑，包括地图解析、实体渲染、状态机管理及交互系统。

## 核心功能模块
- 状态切换：
  
- 字体加载：
    通过 `FontLoader.cpp` 读取完整剧情脚本生成码点集合，只烘焙实际用到的中英文字并补充基础 ASCII，提升字体贴图命中率。
    *   支持多级相对路径查找字体与脚本文本，保证从编辑器或打包目录启动都能成功加载。
    *   若外部字体不可用，会自动回退到 Raylib 默认字体并输出日志，避免因为资源缺失导致 UI 崩溃。

- UI 渲染：
    所有 HUD 与对话框均由 `UI.cpp` 的模板驱动，统一管理纹理与布局参数。
    *   `LoadUIAssets` 负责加载并缓存头像框、血条/蓝条底图等资源，同时填充 `HUDTemplate` 的偏移量。
    *   `DrawHUD` 按实时属性计算 HP/MP 百分比并调用 `DrawTextGlow` 渲染数值，确保战斗与探索界面视觉一致。
    *   对话框绘制使用 `DrawDialogueWithTemplate`，支持有/无头像两种排版，并在同一函数内处理逐字显示与名称栏样式。

- 地图加载：
基于 `tmxlite` 库深度定制，实现了从设计到运行时的无缝衔接。

*   **智能图层分类器**
    *   自动解析 Tiled 图层名称，将其映射为渲染层级：
        *   `Ground/Background`: 地板层（最底层，应用全屏滤镜）。
        *   `YSort` (包含 `Walls`, `Objects`, `Collision`): 实体层（参与动态排序）。
        *   `Decoration`: 挂墙装饰层（通过 Y 轴偏移修正遮挡关系）。
        *   `Overhead`: 头顶遮挡层（永远覆盖角色，如屋顶、门框）。
*   **2.5D 动态遮挡 (Y-Sorting)**
    *   摒弃了传统的“按图层顺序绘制”，构建了一个统一的 `Renderable` 列表。
    *   将**静态物体**与**动态实体**混合，根据**脚底 Y 坐标**进行实时排序 (`std::sort`)，完美解决了“角色绕柱走”时的遮挡穿模问题。
*   **物理碰撞生成**
    *   自动读取名为 `Collision` 的图层或标记为 `WALL` 的图块，生成逻辑网格，实现像素级精度的阻挡检测。
*   **大纹理兼容处理**
    *   解决了显卡纹理尺寸限制（Max 16384px）问题，支持加载切分后的子图集，保证了高清像素素材的兼容性。

- 画面渲染：
  **摄像机**
  使用摄像机，将摄像机中心与角色位置保持一致，以保证角色会一直处于画面正中心。
  **滤镜**
  先绘制所有的地图，对其应用滤镜，再关闭滤镜，把它们绘制成纹理，再在真正的摄像机上先绘制这个绘制好的纹理，再在上面绘制角色。使得地图能保持相同美术风格。

- 角色相关
    实现了玩家角色的核心逻辑，包括动画、移动、属性和状态管理。
    *   **动画系统**:
        *   根据角色的移动方向（上、下、左、右）和状态（站立、移动）自动切换并播放对应的动画序列。
    *   **移动逻辑**:
        *   **输入处理**: 在每一帧检查玩家的按键输入，并以最后的有效按键作为当前移动方向，实现了响应迅速的移动控制。
        *   **逻辑与渲染分离**: 将角色的位置拆分为 `logicPosition` (逻辑网格位置) 和 `visualPosition` (平滑渲染位置)。前者用于碰撞和事件检测，后者通过线性插值 (`Lerp`) 实现平滑的像素级移动动画。当角色完全到达目标图块后，`logicPosition` 才会更新。
        *   **自动吸附**: 在角色移动接近目标图块中心时，会自动吸附到网格的精确位置，防止了因浮点数精度问题导致的坐标偏移和卡位。
        *   **碰撞检测**: 角色在移动前，会使用其目标的 `logicPosition` 查询一个从 Tiled `Collision` 图层生成的逻辑网格。只有当目标位置在网格中为可行走区域时，移动才会被允许，从而实现了基于图块的精确碰撞阻挡。
    *   **属性与状态**:
        *   定义了包含生命值（HP）、法力值（MP）、攻击力、防御力等核心属性的 `Stats` 结构体。

- 事件与对话：
    事件系统驱动地图交互，对话事件与其它玩法事件统一在此模块中调度。
    *   **Tiled 配置**: 在对象层填写 `eventType`、`triggerType`、`scriptPath`、`isOneShot` 等属性即可生成事件，运行时无需重新编译。
    *   **触发方式**: 目前支持 `ON_ENTER_ZONE`、`ON_INTERACT`、`ON_AUTO_START`，由 `CheckEvents` 按帧检测玩家与触发区域。
    *   **事件类型**: 已实现 `DIALOGUE`（加载指定 CSV 剧本后切换到对话状态）、`TELEPORT`（切换地图并更新玩家落点）、`RECOVER`（恢复 HP/MP 并播放说明）。其他类型可按同样结构扩展。
    *   **CSV 剧本格式**: 对话脚本采用 `speaker,portraitPath,text` 行格式，`LoadDialogueScript` 会逐行解析并驱动 `DialogueState` 的逐字显示与头像切换。

- 战斗状态：


- 敌人及NPC：
实现了完全数据驱动的实体系统，无需修改代码即可在编辑器中配置新敌人。

*   **多素材纹理字典 (Texture Map)**
    *   重构了单一纹理加载逻辑，引入 `std::map<string, Texture2D>`。
    *   支持通过 Tiled 的自定义属性 `enemyType` (如 "Pink", "Guard", "Boss") 动态加载并分配不同的外观素材。
*   **网格化移动 AI**
    *   实现了基于 **曼哈顿距离** 的移动算法，强制敌人沿 X 或 Y 轴移动，杜绝了斜向穿墙和卡在墙角的 BUG。
    *   **状态机行为**：
        *   `Patrol`: 在设定半径内随机游荡（包含边界检查）。
        *   `Chasing`: 进入索敌范围后，智能计算路径追击玩家。
*   **属性映射**
    *   自动解析 Tiled 对象属性 (`hp`, `attack`, `speed`) 并注入到 C++ 对象中，实现了“零代码调整数值”。

- 关卡设计：
设计并绘制了三个风格迥异的关卡，均采用环境叙事手法。

*   **Level 0: 隔离协议**
    *   *风格*：红色警报、混乱的办公区。
    *   *机制*：基础移动与交互教学。
*   **Level 0-1: 安全屋**
    *   *风格*：赛博朋克避难所，冷色调，高科技与低生活的结合。
    *   *机制*：剧情中转，无战斗，利用“线缆地狱”和“屏幕墙”营造氛围。
*   **Level 1: 0x00 错误溢出**
    *   *风格*：故障艺术 (Glitch Art)，数据中心。
    *   *机制*：**“恶搞迷宫”**。包含假路障（无碰撞）、假红毯（传送陷阱）、404 虚空房以及由服务器机柜构成的迷宫。

## 游戏玩法

## 外部库：
- **Raylib:** 一个纯 C 语言编写的、简单易用的视频游戏编程库。本项目使用其作为底层引擎，负责窗口创建、2D/3D 图形绘制、音频处理（`Music` 流式播放）、输入响应、字体加载与着色器应用。其轻量、无依赖的特性非常适合从零开始构建游戏框架。

- **tmxlite:** 一个轻量级的、仅头文件的 C++14 库，用于解析 Tiled 地图编辑器生成的 `.tmx` 文件。本项目通过它读取地图的图层、对象、碰撞区以及自定义属性，实现了关卡设计与游戏逻辑的完全分离，让策划和美术可以在 Tiled 中直观地配置事件、敌人属性和传送点，无需修改 C++ 代码。

## 难点

### 1. 2.5D 渲染遮挡关系 (Y-Sorting)
*   **问题：** 在俯视角游戏中，当角色站在墙壁前方时应遮挡墙壁，站在后方时应被墙壁遮挡。简单的图层叠加无法实现动态遮挡。
*   **解决：** 重构了渲染管线。不再按图层顺序绘制，而是提取所有实体（玩家、敌人）和静态物体（墙壁、树木），将其放入一个渲染列表，根据实体的底部 Y 坐标（`visualPosition.y`）进行实时排序（`std::sort`），确保了正确的空间感。

### 2. 显卡纹理尺寸限制 (Texture Limits)
*   **问题：** 使用的高清像素素材包（Modern Interiors）其原始图集高度超过 30,000 像素，超过了主流显卡（如 RTX 3060）的最大纹理限制（16384px），导致游戏内素材显示为黑块。
*   **解决：** 使用AI编写 Python 脚本利用 Pillow 库对超大素材进行自动化切分，将其分割为多张小于 8192px 的子图集，并在 Tiled 中重新映射，解决了硬件兼容性问题。

### 3. Tiled 自定义属性与 C++ 的映射
*   **问题：** 如何让美术/关卡设计在 Tiled 中配置的参数（如敌人血量、巡逻范围、对话脚本路径）直接作用于代码。
*   **解决：** 在 `Map.cpp` 中编写了通用的属性解析器。通过读取 Tiled 对象层的 `Custom Properties`，自动将其转换为 C++ 中的变量（Int/Float/String），实现了“数据驱动”的开发模式，无需修改代码即可调整关卡数值。

### 4. 角色移动与碰撞解耦
*   **问题：** 实时输入切换导致的方向抖动，以及浮点插值累积误差会让角色偏离网格，进一步使事件触发和碰撞判断失准。
*   **解决：** 在 `Player.cpp` 中维护一个输入序列（`inputStack`），每帧清理无效按键并只取最新有效键；移动时分离 `logicPosition` 与 `visualPosition`，以逻辑坐标参与碰撞、事件检测，再用插值驱动渲染坐标，并在接近目标时吸附回网格中心。


### 5. 字体资产烘焙
*   **问题：** 中文文本覆盖面广，若直接使用默认字符集会出现缺字或生成超大字体贴图，且运行目录不同可能导致字体脚本找不到。
*   **解决：** 在 `FontLoader.cpp` 先读取全量剧情脚本，利用 `LoadCodepoints` 统计实际出现的 Unicode 码点再烘焙字体，并按优先级尝试多种路径寻找字体与文本；当所有路径失效时，自动回退到 Raylib 默认字体并记录日志，保证游戏可用性。

### 6. 流式输出对话
*   **问题：** 对话逐字显示需要在任意帧截断文本；若直接按字符长度 `substr`，会把 UTF-8 多字节字符切半，渲染时显示成问号或乱码。
*   **解决：** 在 `Dialogue.cpp` 逐字输出前，读取每个字符的首字节，通过掩码判断当前字符是 1～4 字节，再整体附加到缓冲字符串。这样既能平滑推进打字机效果，又能保证中文与英文都按完整字符显示。

### 7. 滤镜只对地图生效
*   **问题：** 赛博滤镜只针对地图素材统一色调，若直接在最终画面叠加，角色与 UI 也会被染色，导致立绘和 HUD 色彩失真。
*   **解决：** 在 `Player.cpp` 初始化阶段创建离屏渲染纹理，将地图绘制到该纹理并应用滤镜，再把成果纹理绘制到主画面，最后叠加未经处理的角色与 UI，从而限定滤镜作用范围。

### 8. 脚步声循环恢复
*   **问题：** 脚步声原本用短促的 `Sound` 每次触发播放，频繁启停时容易抢占通道或被状态切换中断，出现听不到或卡顿现象；改用 `Music` 流后若缺少持续更新，也会因缓冲耗尽而静音。
*   **解决：** 在 `main.cpp` 通过 `LoadMusicStream` 加载循环资源并多路径容错，进入探索状态时由 `Audio.cpp` 的 `PlayFootstepSound` 按帧检测 `enableFootstepAudio` 与 `player.isMoving`，必要时启动流并每帧 `UpdateMusicStream`，停下后用 `footstepIdleTimer` 延迟 0.1 秒调用 `StopMusicStream`，确保脚步声既能持续播放又不过度抖动。
*   
### 9. 玩家移动不跟手
*   **问题：** 早期逻辑使用单一 if-else 链判断方向，只要按住一个键就会锁死方向，后续输入被忽略，体验与常见 RPG 脱节；同时视觉坐标直接写死成目标网格，导致快速换向时出现瞬移感。
*   **解决：** 在 `Player.cpp::updatePlayer` 中使用输入栈缓存键位，`IsKeyReleased` 后立即剔除无效条目并读取栈顶方向，实现“后覆盖”策略；位移上改为维护 `moveTarget`、`visualPosition` 与 `gridX/Y` 三套坐标，通过 `Vector2MoveTowards` 平滑追赶目标，并在接近中心格时吸附回网格，既跟手又避免浮点漂移。
*   
### 10. 游戏卡顿
*   **问题：** 在游戏过程中，会频繁的出现卡顿，在背景音乐播放时尤为明显，音乐与脚步声出现断续。尝试修改过音乐播放逻辑，但于事无补。
*   **解决：** 在搜索查找后，得知raylib的tracelog可能会阻塞进程，于是便清理掉高频调试日志，并在 `main.cpp` 初始化阶段调用 `SetTraceLogLevel(LOG_WARNING)` 将输出限制在warning及以上，阻塞明显降低，卡顿基本消除。