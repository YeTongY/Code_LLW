# 代号：LLW说明文档

## 项目简介：
本项目是一个简易的俯视角像素风JRPG，以Raylib作为核心图形库。

项目灵感基于科协交流群内梗：LLW病毒

本项目以基于函数指针实现的状态机为基础从底层构建了一套轻量级的游戏框架。游戏以“TUT科协”为背景，融合了赛博朋克与故障艺术风格，玩家将扮演主角 Taffy，在被病毒“LLW”侵蚀的办公大楼中探索真相，净化被感染的同伴。

项目核心目标是实现 RPG 游戏的底层逻辑，包括地图解析、实体渲染、状态机管理及交互系统。通过状态机函数指针实现的生命状态周期函数以及中央数据库（ctx）的设计使得项目各部分高度解耦。开发历程详见Development_log.md

本项目所有美术资源均为原创或资源网站itch.io付费购买

程序路径：Code_LLW\build\LLW.exe

## 小组成员
##### 王宁 jypscript组 20252976
状态机基础架构搭建，探索状态和战斗状态的实现，剧情设计
##### 韦义庭 队乐子辈一组 20252977
玩家模块的实现，UI设计与实现，git和开发环境配置，游戏音频，开发统筹，靠ai加持的兼职美工
##### 郭子博 邦邦邦邦组 20252711
地图设计与制作，敌人模块，tiled大手子主力

## 游戏玩法
游戏内所有模块均包含游戏内操作指南
ps：看到“！”或者“？”记得上前交互

## 项目开发遗憾（By Warning）
战斗模块没有完整实装导致可玩性不高，因为时间和技术力原因剧情没有完整实现，中间删减大量内容（可惜了我写的精彩小剧本）。技术力底下不足以实现战斗特效，导致战斗模块是站桩输出，十分僵硬

## 核心功能模块
- 状态切换：
    基于函数指针实现的轻量级状态机，是整个游戏引擎的核心架构。
    *   **状态机管理器 (GameStateMachine)**：
        *   维护 `current_state` 和 `pending_state` 两个指针，实现状态的安全切换机制。
        *   `GameStateMachine_change` 负责状态过渡，先调用旧状态的 `exit` 函数清理资源，再调用新状态的 `enter` 函数初始化。
        *   在主循环中通过 `GameStateMachine_update` 和 `GameStateMachine_render` 分离更新与渲染逻辑，确保帧率稳定。
    *   **生命周期函数**：
        *   每个游戏状态（`GameState`）必须实现四个函数指针：`enter`（初始化）、`exit`（清理）、`update`（逻辑更新）、`render`（画面绘制）。
        *   通过 `Gamestate_create` 统一创建状态对象，并将状态专属数据（如 `ExplorationData`, `CombatData`）封装在 `void* data` 中，实现了状态间的数据隔离。
    *   **核心状态实现**：
        *   `TitleScreenState`：标题界面，显示游戏 Logo 和开始提示。
        *   `ExplorationState`：探索状态，玩家在地图中移动、触发事件、与 NPC 交互，是游戏的主要状态。
        *   `CombatState`：回合制战斗状态，管理玩家与敌人的行动顺序、技能释放和胜负判定。
        *   `DialogueState`：对话状态，加载 CSV 剧本并驱动逐字显示与头像切换，支持战斗前后剧情触发。
    *   **状态切换触发条件**：
        *   探索 → 战斗：玩家与敌人碰撞检测成功。
        *   战斗 → 对话：战斗结束后触发战后剧情（如果配置了 `pendingPostCombatDialogue`）。
        *   对话 → 探索：剧本播放完毕后自动返回。
        *   任意状态 → 标题：通过 ESC 键或游戏结束触发。
    *   **中央数据库 (GameContext)**：
        *   所有状态共享同一个 `GameContext` 指针，其中包含玩家、敌人、地图、摄像机、UI 模板、音频资源等全局数据。
        *   状态切换时只改变状态机的当前状态，`GameContext` 中的数据保持连续性，避免了数据丢失和重复加载。
  
- 字体加载：
    通过 `FontLoader.cpp` 读取完整剧情脚本生成码点集合，只烘焙实际用到的中英文字并补充基础 ASCII，提升字体贴图命中率。
    *   支持多级相对路径查找字体与脚本文本，保证从编辑器或打包目录启动都能成功加载。
    *   若外部字体不可用，会自动回退到 Raylib 默认字体并输出日志，避免因为资源缺失导致 UI 崩溃。

- UI 渲染：
    所有 HUD 与对话框均由 `UI.cpp` 的模板驱动，统一管理纹理与布局参数。
    *   `LoadUIAssets` 负责加载并缓存头像框、血条/蓝条底图等资源，同时填充 `HUDTemplate` 的偏移量。
    *   `DrawHUD` 按实时属性计算 HP/MP 百分比并调用 `DrawTextGlow` 渲染数值，确保战斗与探索界面视觉一致。
    *   对话框绘制使用 `DrawDialogueWithTemplate`，支持有/无头像两种排版，并在同一函数内处理逐字显示与名称栏样式。

- 地图加载：
基于 `tmxlite` 库深度定制，实现了从设计到运行时的无缝衔接。

*   **智能图层分类器**
    *   自动解析 Tiled 图层名称，将其映射为渲染层级：
        *   `Ground/Background`: 地板层（最底层，应用全屏滤镜）。
        *   `YSort` (包含 `Walls`, `Objects`, `Collision`): 实体层（参与动态排序）。
        *   `Decoration`: 挂墙装饰层（通过 Y 轴偏移修正遮挡关系）。
        *   `Overhead`: 头顶遮挡层（永远覆盖角色，如屋顶、门框）。
*   **2.5D 动态遮挡 (Y-Sorting)**
    *   摒弃了传统的“按图层顺序绘制”，构建了一个统一的 `Renderable` 列表。
    *   将**静态物体**与**动态实体**混合，根据**脚底 Y 坐标**进行实时排序 (`std::sort`)，完美解决了“角色绕柱走”时的遮挡穿模问题。
*   **物理碰撞生成**
    *   自动读取名为 `Collision` 的图层或标记为 `WALL` 的图块，生成逻辑网格，实现像素级精度的阻挡检测。
*   **大纹理兼容处理**
    *   解决了显卡纹理尺寸限制（Max 16384px）问题，支持加载切分后的子图集，保证了高清像素素材的兼容性。

- 画面渲染：
  **摄像机**
  使用摄像机，将摄像机中心与角色位置保持一致，以保证角色会一直处于画面正中心。
  **滤镜**
  先绘制所有的地图，对其应用滤镜，再关闭滤镜，把它们绘制成纹理，再在真正的摄像机上先绘制这个绘制好的纹理，再在上面绘制角色。使得地图能保持相同美术风格。

- 角色相关
    实现了玩家角色的核心逻辑，包括动画、移动、属性和状态管理。
    *   **动画系统**:
        *   根据角色的移动方向（上、下、左、右）和状态（站立、移动）自动切换并播放对应的动画序列。
    *   **移动逻辑**:
        *   **输入处理**: 在每一帧检查玩家的按键输入，并以最后的有效按键作为当前移动方向，实现了响应迅速的移动控制。
        *   **逻辑与渲染分离**: 将角色的位置拆分为 `logicPosition` (逻辑网格位置) 和 `visualPosition` (平滑渲染位置)。前者用于碰撞和事件检测，后者通过线性插值 (`Lerp`) 实现平滑的像素级移动动画。当角色完全到达目标图块后，`logicPosition` 才会更新。
        *   **自动吸附**: 在角色移动接近目标图块中心时，会自动吸附到网格的精确位置，防止了因浮点数精度问题导致的坐标偏移和卡位。
        *   **碰撞检测**: 角色在移动前，会使用其目标的 `logicPosition` 查询一个从 Tiled `Collision` 图层生成的逻辑网格。只有当目标位置在网格中为可行走区域时，移动才会被允许，从而实现了基于图块的精确碰撞阻挡。
    *   **属性与状态**:
        *   定义了包含生命值（HP）、法力值（MP）、攻击力、防御力等核心属性的 `Stats` 结构体。

- 事件与对话：
    事件系统驱动地图交互，对话事件与其它玩法事件统一在此模块中调度。
    *   **Tiled 配置**: 在对象层填写 `eventType`、`triggerType`、`scriptPath`、`isOneShot` 等属性即可生成事件，运行时无需重新编译。
    *   **触发方式**: 目前支持 `ON_ENTER_ZONE`、`ON_INTERACT`、`ON_AUTO_START`，由 `CheckEvents` 按帧检测玩家与触发区域。
    *   **事件类型**: 已实现 `DIALOGUE`（加载指定 CSV 剧本后切换到对话状态）、`TELEPORT`（切换地图并更新玩家落点）、`RECOVER`（恢复 HP/MP 并播放说明）。其他类型可按同样结构扩展。
    *   **CSV 剧本格式**: 对话脚本采用 `speaker,portraitPath,text` 行格式，`LoadDialogueScript` 会逐行解析并驱动 `DialogueState` 的逐字显示与头像切换。

- 战斗状态：
    战斗状态由 `CombatState` 管理，负责玩家与敌人的回合制对抗、技能释放以及胜负结算。
    *   **生命周期回调**：
        *   `combat_enter` 绑定当前敌人、加载战斗背景、创建 `HUDTemplate`。若配置了 `pendingPreCombatDialogue` 会先切到对话状态再回到战斗。
        *   `combat_update` 按帧驱动：处理输入（选择普通攻击、防御、技能、物品、逃跑）、结算行动逻辑、播放动画计时、监控胜败条件。
        *   `combat_render` 负责绘制战斗背景、敌我立绘、行动列表、HP/MP 条与提示文本，并通过 `DrawHUD` 保持与探索状态一致的 UI 风格。
    *   **回合流程**：
        *   使用 `isPlayerTurn` 标志控制主动权；玩家回合读取输入执行行动，随后切换到敌人回合。
        *   敌人行为通过简单 AI 或脚本化指令（如固定技能循环、HP 阈值触发技能）。
        *   动作结算采用“行动队列 + 延迟显示”模式，先计算伤害/治疗，再通过浮动文本与音效呈现。
    *   **技能与资源**：
        *   技能数据存放在 `skills.json`（或硬编码数组）并映射到 `Skills` 结构，包含伤害、命中、MP 消耗、附加效果（加防、恢复等）。
        *   玩家拥有 `secret skill`、`basic skill` 等分类，UI 在任意状态下都会展示技能列表（最近一次需求为“始终显示隐藏技”）。
        *   `Stats` 中的 `mp`/`maxMp` 在战斗中实时扣减，胜利后通过 `pendingPostCombatDialogue` 或事件恢复 40% 已损生命、指定 MP 值。
    *   **状态切换**：
        *   `player.hp <= 0` 时切换到失败处理（目前返回标题或触发 Game Over 对话）。
        *   敌人全灭则触发战利品事件、出队 `currentCombatant` 并回到探索；若定义了 `recover` 事件则在离开前执行。
        *   战斗结束后根据配置进入 `DialogueState`、`ExplorationState` 或直接播放过场。


- 敌人及NPC：
实现了完全数据驱动的实体系统，无需修改代码即可在编辑器中配置新敌人。

*   **多素材纹理字典 (Texture Map)**
    *   重构了单一纹理加载逻辑，引入 `std::map<string, Texture2D>`。
    *   支持通过 Tiled 的自定义属性 `enemyType` (如 "Pink", "Guard", "Boss") 动态加载并分配不同的外观素材。
*   **网格化移动 AI**
    *   实现了基于 **曼哈顿距离** 的移动算法，强制敌人沿 X 或 Y 轴移动，杜绝了斜向穿墙和卡在墙角的 BUG。
    *   **状态机行为**：
        *   `Patrol`: 在设定半径内随机游荡（包含边界检查）。
        *   `Chasing`: 进入索敌范围后，智能计算路径追击玩家。
*   **属性映射**
    *   自动解析 Tiled 对象属性 (`hp`, `attack`, `speed`) 并注入到 C++ 对象中，实现了“零代码调整数值”。

## 游戏玩法

## 外部库：
- **Raylib:** 一个纯 C 语言编写的、简单易用的视频游戏编程库。本项目使用其作为底层引擎，负责窗口创建、2D/3D 图形绘制、音频处理（`Music` 流式播放）、输入响应、字体加载与着色器应用。其轻量、无依赖的特性非常适合从零开始构建游戏框架。

- **tmxlite:** 一个轻量级的、仅头文件的 C++14 库，用于解析 Tiled 地图编辑器生成的 `.tmx` 文件。本项目通过它读取地图的图层、对象、碰撞区以及自定义属性，实现了关卡设计与游戏逻辑的完全分离，让策划和美术可以在 Tiled 中直观地配置事件、敌人属性和传送点，无需修改 C++ 代码。

## 难点

### 1. 2.5D 渲染遮挡关系 (Y-Sorting)
*   **问题：** 在俯视角游戏中，当角色站在墙壁前方时应遮挡墙壁，站在后方时应被墙壁遮挡。简单的图层叠加无法实现动态遮挡。
*   **解决：** 重构了渲染管线。不再按图层顺序绘制，而是提取所有实体（玩家、敌人）和静态物体（墙壁、树木），将其放入一个渲染列表，根据实体的底部 Y 坐标（`visualPosition.y`）进行实时排序（`std::sort`），确保了正确的空间感。

### 2. 显卡纹理尺寸限制 (Texture Limits)
*   **问题：** 使用的高清像素素材包（Modern Interiors）其原始图集高度超过 30,000 像素，超过了主流显卡（如 RTX 3060）的最大纹理限制（16384px），导致游戏内素材显示为黑块。
*   **解决：** 使用AI编写 Python 脚本利用 Pillow 库对超大素材进行自动化切分，将其分割为多张小于 8192px 的子图集，并在 Tiled 中重新映射，解决了硬件兼容性问题。

### 3. Tiled 自定义属性与 C++ 的映射
*   **问题：** 如何让美术/关卡设计在 Tiled 中配置的参数（如敌人血量、巡逻范围、对话脚本路径）直接作用于代码。
*   **解决：** 在 `Map.cpp` 中编写了通用的属性解析器。通过读取 Tiled 对象层的 `Custom Properties`，自动将其转换为 C++ 中的变量（Int/Float/String），实现了“数据驱动”的开发模式，无需修改代码即可调整关卡数值。

### 4. 角色移动与碰撞解耦
*   **问题：** 实时输入切换导致的方向抖动，以及浮点插值累积误差会让角色偏离网格，进一步使事件触发和碰撞判断失准。
*   **解决：** 在 `Player.cpp` 中维护一个输入序列（`inputStack`），每帧清理无效按键并只取最新有效键；移动时分离 `logicPosition` 与 `visualPosition`，以逻辑坐标参与碰撞、事件检测，再用插值驱动渲染坐标，并在接近目标时吸附回网格中心。


### 5. 字体资产烘焙
*   **问题：** 中文文本覆盖面广，若直接使用默认字符集会出现缺字或生成超大字体贴图，且运行目录不同可能导致字体脚本找不到。
*   **解决：** 在 `FontLoader.cpp` 先读取全量剧情脚本，利用 `LoadCodepoints` 统计实际出现的 Unicode 码点再烘焙字体，并按优先级尝试多种路径寻找字体与文本；当所有路径失效时，自动回退到 Raylib 默认字体并记录日志，保证游戏可用性。

### 6. 流式输出对话
*   **问题：** 对话逐字显示需要在任意帧截断文本；若直接按字符长度 `substr`，会把 UTF-8 多字节字符切半，渲染时显示成问号或乱码。
*   **解决：** 在 `Dialogue.cpp` 逐字输出前，读取每个字符的首字节，通过掩码判断当前字符是 1～4 字节，再整体附加到缓冲字符串。这样既能平滑推进打字机效果，又能保证中文与英文都按完整字符显示。

### 7. 滤镜只对地图生效
*   **问题：** 赛博滤镜只针对地图素材统一色调，若直接在最终画面叠加，角色与 UI 也会被染色，导致立绘和 HUD 色彩失真。
*   **解决：** 在 `Player.cpp` 初始化阶段创建离屏渲染纹理，将地图绘制到该纹理并应用滤镜，再把成果纹理绘制到主画面，最后叠加未经处理的角色与 UI，从而限定滤镜作用范围。

### 8. 脚步声循环恢复
*   **问题：** 脚步声原本用短促的 `Sound` 每次触发播放，频繁启停时容易抢占通道或被状态切换中断，出现听不到或卡顿现象；改用 `Music` 流后若缺少持续更新，也会因缓冲耗尽而静音。
*   **解决：** 在 `main.cpp` 通过 `LoadMusicStream` 加载循环资源并多路径容错，进入探索状态时由 `Audio.cpp` 的 `PlayFootstepSound` 按帧检测 `enableFootstepAudio` 与 `player.isMoving`，必要时启动流并每帧 `UpdateMusicStream`，停下后用 `footstepIdleTimer` 延迟 0.1 秒调用 `StopMusicStream`，确保脚步声既能持续播放又不过度抖动。
*   
### 9. 玩家移动不跟手
*   **问题：** 早期逻辑使用单一 if-else 链判断方向，只要按住一个键就会锁死方向，后续输入被忽略，体验与常见 RPG 脱节；同时视觉坐标直接写死成目标网格，导致快速换向时出现瞬移感。
*   **解决：** 在 `Player.cpp::updatePlayer` 中使用输入栈缓存键位，`IsKeyReleased` 后立即剔除无效条目并读取栈顶方向，实现“后覆盖”策略；位移上改为维护 `moveTarget`、`visualPosition` 与 `gridX/Y` 三套坐标，通过 `Vector2MoveTowards` 平滑追赶目标，并在接近中心格时吸附回网格，既跟手又避免浮点漂移。
*   
### 10. 游戏卡顿
*   **问题：** 在后期开发版本的游戏过程中，会频繁的出现卡顿，在背景音乐播放时尤为明显，音乐与脚步声出现断续。尝试修改过音乐播放逻辑，但于事无补。
*   **解决：** 在搜索查找后，得知raylib的tracelog可能会阻塞进程，于是便清理掉高频调试日志，并在 `main.cpp` 初始化阶段调用 `SetTraceLogLevel(LOG_WARNING)` 将输出限制在warning及以上，阻塞明显降低，卡顿基本消除。

### 11. 状态机切换一致性
*   **问题：** 多个状态（探索、战斗、对话、标题）需要在同一帧内频繁切换，若直接替换函数指针或在状态内手动调用其他状态函数，极易导致重复初始化、资源未释放或回调交叉。尤其在“探索→战斗→对话→探索”的链式流程中，稍有时序错误就会出现 HUD 未加载、音乐未停止或摄像机指针悬空等问题。
*   **解决：** 设计 `GameStateMachine` 维护 `current_state` 与 `pending_state`，所有切换统一通过 `GameStateMachine_change` 排队处理，保证上一状态的 `exit` 总在下一状态 `enter` 前执行。每个状态的数据通过 `Gamestate_create` 单独分配并由状态机负责销毁，从而让状态切换完全“无副作用”，任何模块都只需调用一次 change 接口即可完成过渡。

### 12. 战斗模块的回合同步
*   **问题：** 战斗里要同时处理输入选项、技能前后摇、敌人 AI 行动、飘字动画和事件触发。若简单用 `if (isPlayerTurn)` 立即切换，会出现输入被重复读取、敌人多次行动或技能特效被截断，尤其在战斗结束需要接驳后续剧情/恢复事件时，逻辑极易错乱。
*   **解决：** 引入“行动状态机”概念：`combat_update` 先将玩家输入写入 `CombatAction` 队列，按“准备→执行→收尾”三个子阶段推进，并在每阶段内锁定 UI 交互。敌人 AI 也以同样方式排队执行，帧结束时再统一切换 `isPlayerTurn`。结算阶段会检测 HP、奖励、pending 对话和恢复事件，确保战斗结束后能无缝地回到探索或对话状态，彻底杜绝了多次触发与顺序错乱问题。